package ca

import (
	"crypto/tls"
	"net/http"

	"github.com/pkg/errors"
	"github.com/smallstep/certificates/api"
	"github.com/smallstep/certificates/ca"
	"github.com/smallstep/cli/command"
	"github.com/smallstep/cli/crypto/pki"
	"github.com/smallstep/cli/crypto/x509util"
	"github.com/smallstep/cli/errs"
	"github.com/smallstep/cli/ui"
	"github.com/urfave/cli"
)

func revokeCertificateCommand() cli.Command {
	return cli.Command{
		Name:   "revoke",
		Action: command.ActionFunc(revokeCertificateAction),
		Usage:  "revoke a certificate",
		UsageText: `**step ca revoke** <serial-number> <reason>
[**--crt**=<certificate>] [**--key**=<key>] [**--token**=<ott>]
[**--kid**=<key-id>] [**--ca-url**=<uri>] [**--root**=<file>]
[**--reason**=<string>] [**-offline**]`,
		Description: `
**step ca revoke** command passively revokes a certificate with the given serial
number.

NOTE: This command currently only supports passive revocation. Passive revocation
means preventing a certificate from being renewed and letting it expire.

TODO: Add support for CRL and OCSP.

## POSITIONAL ARGUMENTS

<serial-number>
:  The serial number of the certificate that should be revoked.

## EXAMPLES

Revoke a certificate using a transparently generated token and the default reason:
'''
$ step ca revoke 308893286343609293989051180431574390766
'''

Revoke a certificate using a transparently generated token and configured reason:
'''
$ step ca revoke --reason "KeyCompromise" 308893286343609293989051180431574390766
'''

Revoke a certificate using that same certificate to setup an mTLS connection
with the CA:
'''
$ step ca revoke --crt mike.crt --key mike.key 308893286343609293989051180431574390766
'''

Revoke a certificate using a transparently generated token:
'''
$ step ca revoke "KeyCompromise"
'''

Revoke a certificate using a token, generated by a provisioner, to authorize
the request with the CA:
'''
$ step ca revoke --token <token> --reason "KeyCompromise" 308893286343609293989051180431574390766
'''`,
		Flags: []cli.Flag{
			cli.StringFlag{
				Name:  "reason",
				Value: "",
				Usage: `The <reason> for which the certificate is being revoked.
If unset, default is Unspecified.

: <reason> is case-insensitive and must be one of:

    **Unspecified**

    **KeyCompromise**

    **CACompromise**

    **AffiliationChanged**

    **Superseded**

    **CessationOfOperation**

    **CertificateHold**

    **RemoveFromCRL**

    **PrivilegeWithdrawn**

    **AACompromise**
`,
			},
			cli.StringFlag{
				Name:  "crt",
				Usage: `The path to the <crt> that should be revoked.`,
			},
			cli.StringFlag{
				Name:  "key",
				Usage: `The path to the <key> corresponding to the cert that should be revoked.`,
			},
			tokenFlag,
			provisionerKidFlag,
			caURLFlag,
			rootFlag,
			offlineFlag,
			caConfigFlag,
		},
	}
}

func revokeCertificateAction(ctx *cli.Context) error {
	err := errs.NumberOfArguments(ctx, 1)
	if err != nil {
		return err
	}

	args := ctx.Args()
	crtFile := ctx.String("crt")
	keyFile := ctx.String("key")
	token := ctx.String("token")
	reason := ctx.String("reason")
	serial := args.Get(0)

	rootFile := ctx.String("root")
	if len(rootFile) == 0 {
		rootFile = pki.GetRootCAPath()
	}

	caURL := ctx.String("ca-url")
	if len(caURL) == 0 {
		return errs.RequiredFlag(ctx, "ca-url")
	}

	if err != nil {
		return errs.InvalidFlagValue(ctx, "reason", reason,
			"Unspecified, KeyCompromise, CACompromise, AffiliationChanged, "+
				"Superseded, CessationOfOperation, CertificateHold, RemoveFromCRL,"+
				"PrivilegeWithdrawn, AACompromise")
	}

	if len(token) > 0 {
		if len(crtFile) > 0 {
			errs.IncompatibleFlag(ctx, "token", "crt")
		}
		if len(keyFile) > 0 {
			errs.IncompatibleFlag(ctx, "token", "key")
		}
	} else if len(crtFile) > 0 || len(keyFile) > 0 {
		if len(crtFile) == 0 {
			return errs.RequiredWithFlag(ctx, "key", "crt")
		}
		if len(keyFile) == 0 {
			return errs.RequiredWithFlag(ctx, "crt", "key")
		}
	}

	r, err := newRevoker(ctx, caURL, crtFile, keyFile, rootFile)
	if err != nil {
		return err
	}
	if r.revoke(&api.RevokeRequest{
		Serial: serial,
		Reason: reason,
		OTT:    token,
	}); err != nil {
		return err
	}

	ui.Printf("Certificate with Serial Number %s has been revoked.\n", serial)
	return nil
}

type revoker struct {
	client    caClient
	transport *http.Transport
	keyFile   string
	offline   bool
}

func newRevoker(ctx *cli.Context, caURL, crtFile, keyFile, rootFile string) (*revoker, error) {
	var client caClient

	rootCAs, err := x509util.ReadCertPool(rootFile)
	if err != nil {
		return nil, err
	}

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{
			RootCAs:                  rootCAs,
			PreferServerCipherSuites: true,
		},
	}

	if len(crtFile) > 0 {
		cert, err := tls.LoadX509KeyPair(crtFile, keyFile)
		if err != nil {
			return nil, errors.Wrap(err, "error loading certificates")
		}
		if len(cert.Certificate) == 0 {
			return nil, errors.New("error loading certificate: certificate chain is empty")
		}
		tr.TLSClientConfig.Certificates = []tls.Certificate{cert}
	}

	offline := ctx.Bool("offline")
	if offline {
		caConfig := ctx.String("ca-config")
		if caConfig == "" {
			return nil, errs.InvalidFlagValue(ctx, "ca-config", "", "")
		}
		client, err = newOfflineCA(caConfig)
		if err != nil {
			return nil, err
		}
	} else {
		client, err = ca.NewClient(caURL, ca.WithTransport(tr))
		if err != nil {
			return nil, err
		}
	}

	return &revoker{
		client:    client,
		transport: tr,
		keyFile:   keyFile,
		offline:   offline,
	}, nil
}

func (r *revoker) revoke(req *api.RevokeRequest) (*api.RevokeResponse, error) {
	return r.client.Revoke(req, r.transport)
}
